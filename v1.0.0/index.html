<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · QXTns.jl</title><link rel="canonical" href="https://JuliaQX.github.io/QXTns.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.svg" alt="QXTns.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">QXTns.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Example-usage"><span>Example usage</span></a></li><li><a class="tocitem" href="#Contributing"><span>Contributing</span></a></li><li><a class="tocitem" href="#Building-documentation"><span>Building documentation</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li></ul></li><li><a class="tocitem" href="data_structures/">Data Structures</a></li><li><a class="tocitem" href="license/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQX/QXTns.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QXTns"><a class="docs-heading-anchor" href="#QXTns">QXTns</a><a id="QXTns-1"></a><a class="docs-heading-anchor-permalink" href="#QXTns" title="Permalink"></a></h1><p>QXTns is a Julia package with data structures and utilities for manipulating tensor networks. As well as generic tensor network data structure, it also contains specific data structures for handling tensor networks derived from quantum circuits. It was developed as part of the QuantEx project, one of the individual software projects of WP8 of PRACE 6IP.</p><p>It uses some features from <a href="https://github.com/ITensor/ITensors.jl">ITensors</a> and <a href="https://github.com/ITensor/NDTensors.jl">NDTensors</a> for representing tensors and indices and performing contractions.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>QXTns is a Julia package and can be installed using Julia&#39;s inbuilt package manager from the Julia REPL using.</p><pre><code class="language-none">import Pkg
Pkg.add(&quot;QXTns&quot;)</code></pre><p>To ensure everything is working, the unittests can be run using</p><pre><code class="language-none">import Pkg; Pkg.test()</code></pre><h2 id="Example-usage"><a class="docs-heading-anchor" href="#Example-usage">Example usage</a><a id="Example-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Example-usage" title="Permalink"></a></h2><p>An example of creating a simple tensor network and contracting.</p><pre><code class="language-none">using QXTns

tn = TensorNetwork()

a, b, c, d = Index(2), Index(3), Index(5), Index(4)

# add a 2x3x5 rank tensor
push!(tn, [a, b, c], rand(2, 3, 5))
# add a 5x4 matrix
push!(tn, [c, d], rand(5, 4))

# contract network
simple_contraction!(tn)

# number of tensors after contraction
@show length(tn)

# resulting tensor has dimensions should have dimensions 2x3x4
@show size(first(tn))</code></pre><h2 id="Contributing"><a class="docs-heading-anchor" href="#Contributing">Contributing</a><a id="Contributing-1"></a><a class="docs-heading-anchor-permalink" href="#Contributing" title="Permalink"></a></h2><p>Contributions from users are welcome and we encourage users to open issues and submit merge/pull requests for any problems or feature requests they have. The CONTRIBUTING.md on the top level of the source folder has further details of the contribution guidelines.</p><h2 id="Building-documentation"><a class="docs-heading-anchor" href="#Building-documentation">Building documentation</a><a id="Building-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Building-documentation" title="Permalink"></a></h2><p>QXTns.jl uses <a href="https://juliadocs.github.io/Documenter.jl/stable/">Documenter.jl</a> to generate documentation. To build the documentation locally run the following from the root folder.</p><p>The first time it is will be necessary to instantiate the environment to install dependencies</p><pre><code class="language-none">julia --project=docs/ -e &#39;using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()&#39;</code></pre><p>and then to build the documentation</p><pre><code class="language-none">julia --project=docs/ docs/make.jl</code></pre><p>The generated document will be in the <code>docs/build</code> folder. To serve these locally one can use the LiveServer package as</p><pre><code class="language-none">julia --project -e &#39;import Pkg; Pkg.add(&quot;LiveServer&quot;);
julia --project -e  &#39;using LiveServer; serve(dir=&quot;docs/build&quot;)&#39;</code></pre><p>Or with python3 using from the <code>docs/build</code> folder using</p><pre><code class="language-none">python3 -m http.server</code></pre><p>The generated documentation should now be viewable locally in a browser at <code>http://localhost:8000</code>.</p><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><ul><li><a href="#QXTns.MockTensor"><code>QXTns.MockTensor</code></a></li><li><a href="data_structures/#QXTns.QXTensor"><code>QXTns.QXTensor</code></a></li><li><a href="#QXTns.QXTensor-Tuple{Number}"><code>QXTns.QXTensor</code></a></li><li><a href="#QXTns.QXTensor"><code>QXTns.QXTensor</code></a></li><li><a href="data_structures/#QXTns.TensorNetwork"><code>QXTns.TensorNetwork</code></a></li><li><a href="#QXTns.TensorNetwork-Tuple{Vector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:QXTensor}"><code>QXTns.TensorNetwork</code></a></li><li><a href="data_structures/#QXTns.TensorNetworkCircuit"><code>QXTns.TensorNetworkCircuit</code></a></li><li><a href="#Base.copy-Union{Tuple{QXTns.BlockTensor{T, N, M} where M}, Tuple{N}, Tuple{T}} where {T, N}"><code>Base.copy</code></a></li><li><a href="#Base.copy-Union{Tuple{MockTensor{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>Base.copy</code></a></li><li><a href="#Base.delete!-Tuple{TensorNetworkCircuit, Symbol}"><code>Base.delete!</code></a></li><li><a href="#Base.delete!-Tuple{TensorNetwork, Symbol}"><code>Base.delete!</code></a></li><li><a href="#Base.getindex-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{QXTns.BlockTensor{T, N, M}, Vararg{Any, N} where N}} where {T, N, M}"><code>Base.getindex</code></a></li><li><a href="#Base.merge-Tuple{TensorNetwork, TensorNetwork}"><code>Base.merge</code></a></li><li><a href="#Base.push!-Union{Tuple{N}, Tuple{T}, Tuple{TensorNetwork, Vector{var&quot;#s27&quot;} where var&quot;#s27&quot;&lt;:Index, Array{T, N}}} where {T, N}"><code>Base.push!</code></a></li><li><a href="#Base.push!-Union{Tuple{T}, Tuple{TensorNetworkCircuit, Vector{Int64}, Matrix{T}}} where T"><code>Base.push!</code></a></li><li><a href="#Base.push!-Tuple{TensorNetwork, QXTensor}"><code>Base.push!</code></a></li><li><a href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, QXTensor}"><code>Base.show</code></a></li><li><a href="#Base.size-Tuple{QXTensor}"><code>Base.size</code></a></li><li><a href="#NDTensors.inds-Tuple{QXTensor}"><code>NDTensors.inds</code></a></li><li><a href="#NDTensors.store-Tuple{QXTensor}"><code>NDTensors.store</code></a></li><li><a href="#QXTns.add_input!"><code>QXTns.add_input!</code></a></li><li><a href="#QXTns.add_output!"><code>QXTns.add_output!</code></a></li><li><a href="#QXTns.contract_pair-Tuple{TensorNetwork, Symbol, Symbol}"><code>QXTns.contract_pair</code></a></li><li><a href="#QXTns.contract_pair!"><code>QXTns.contract_pair!</code></a></li><li><a href="#QXTns.contract_tensors-Tuple{QXTensor, QXTensor}"><code>QXTns.contract_tensors</code></a></li><li><a href="#QXTns.contract_tn!-Tuple{TensorNetwork, Vector{Tuple{Symbol, Symbol, Symbol}}}"><code>QXTns.contract_tn!</code></a></li><li><a href="#QXTns.contraction_indices-Tuple{TensorNetwork, Symbol, Symbol}"><code>QXTns.contraction_indices</code></a></li><li><a href="#QXTns.contraction_indices-Tuple{QXTensor, QXTensor}"><code>QXTns.contraction_indices</code></a></li><li><a href="#QXTns.create_test_tnc-Tuple{}"><code>QXTns.create_test_tnc</code></a></li><li><a href="#QXTns.decompose_gate"><code>QXTns.decompose_gate</code></a></li><li><a href="#QXTns.decompose_tensor!-Tuple{TensorNetwork, Symbol, Vector{var&quot;#s27&quot;} where var&quot;#s27&quot;&lt;:Index}"><code>QXTns.decompose_tensor!</code></a></li><li><a href="#QXTns.disable_hyperindices!-Tuple{QXTensor}"><code>QXTns.disable_hyperindices!</code></a></li><li><a href="#QXTns.expand_tensor-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Vector{Vector{Int64}}}} where {Elt, N}"><code>QXTns.expand_tensor</code></a></li><li><a href="#QXTns.find_connected_indices-Tuple{TensorNetwork, Index}"><code>QXTns.find_connected_indices</code></a></li><li><a href="#QXTns.find_hyper_edges-Union{Tuple{AbstractArray{Elt, N}}, Tuple{N}, Tuple{Elt}} where {Elt, N}"><code>QXTns.find_hyper_edges</code></a></li><li><a href="#QXTns.get_hyperedges-Tuple{TensorNetwork}"><code>QXTns.get_hyperedges</code></a></li><li><a href="#QXTns.hyperindices-Tuple{TensorNetwork, Symbol}"><code>QXTns.hyperindices</code></a></li><li><a href="#QXTns.hyperindices-Tuple{QXTensor}"><code>QXTns.hyperindices</code></a></li><li><a href="#QXTns.indices2ranks-Tuple{QXTensor, Vector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:(Vector{var&quot;#s28&quot;} where var&quot;#s28&quot;&lt;:Index)}"><code>QXTns.indices2ranks</code></a></li><li><a href="#QXTns.isdiagonal-Union{Tuple{AbstractMatrix{Elt}}, Tuple{Elt}} where Elt"><code>QXTns.isdiagonal</code></a></li><li><a href="#QXTns.isdiagonal-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Pair{Int64, Int64}}} where {Elt, N}"><code>QXTns.isdiagonal</code></a></li><li><a href="#QXTns.neighbours-Tuple{TensorNetwork, Symbol}"><code>QXTns.neighbours</code></a></li><li><a href="#QXTns.push_input!-Union{Tuple{Elt}, Tuple{TensorNetworkCircuit, Vector{Elt}, Int64}} where Elt"><code>QXTns.push_input!</code></a></li><li><a href="#QXTns.push_output!-Union{Tuple{Elt}, Tuple{TensorNetworkCircuit, Vector{Elt}, Int64}} where Elt"><code>QXTns.push_output!</code></a></li><li><a href="#QXTns.reduce_tensor-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Vector{Vector{Int64}}}} where {Elt, N}"><code>QXTns.reduce_tensor</code></a></li><li><a href="#QXTns.replace_tensor_symbol!-Tuple{TensorNetwork, Symbol, Symbol}"><code>QXTns.replace_tensor_symbol!</code></a></li><li><a href="#QXTns.simple_contraction-Tuple{TensorNetwork}"><code>QXTns.simple_contraction</code></a></li><li><a href="#QXTns.simple_contraction!-Tuple{TensorNetwork}"><code>QXTns.simple_contraction!</code></a></li><li><a href="#QXTns.tensor_data-Tuple{QXTensor}"><code>QXTns.tensor_data</code></a></li><li><a href="#QXTns.tensor_data-Tuple{TensorNetwork, Symbol}"><code>QXTns.tensor_data</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QXTns.MockTensor" href="#QXTns.MockTensor"><code>QXTns.MockTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tensor store struct that just tracks tensor dimensions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/mock_tensor.jl#LL13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.QXTensor" href="#QXTns.QXTensor"><code>QXTns.QXTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QXTensor(indices::Vector{&lt;:Index},
         hyper_indices::Union{Nothing, Vector{&lt;:Vector{Int64}}},
         storage::Union{Nothing, &lt;: AbstractArray}=nothing;
         diagonal_check::Bool=true)</code></pre><p>QXTensor constructor creates a new instance of QXTensor with the given indices and hyper indices. If no storage data structure is given then a MockTensor of that shape is added as the storage. If diagonal<em>check is true, it will automaticallly check which indices are hyper indices and record in the hyper</em>indices field. If hyper_indices are given, then these are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor.jl#LL43-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.QXTensor-Tuple{Number}" href="#QXTns.QXTensor-Tuple{Number}"><code>QXTns.QXTensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QXTensor(a::T) where T &lt;: Number</code></pre><p>QXTensor constructor which creates a new instance of QXTensor corresponding to a scalar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor.jl#LL34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.TensorNetwork-Tuple{Vector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:QXTensor}" href="#QXTns.TensorNetwork-Tuple{Vector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:QXTensor}"><code>QXTns.TensorNetwork</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TensorNetwork(array::Vector{&lt;: QXTensor})</code></pre><p>Outer constructor to create a tensor network object from an array of ITensor objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Union{Tuple{MockTensor{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#Base.copy-Union{Tuple{MockTensor{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Overload functions from base to make MockTensor usable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/mock_tensor.jl#LL20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Union{Tuple{QXTns.BlockTensor{T, N, M} where M}, Tuple{N}, Tuple{T}} where {T, N}" href="#Base.copy-Union{Tuple{QXTns.BlockTensor{T, N, M} where M}, Tuple{N}, Tuple{T}} where {T, N}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Overload functions from base to make BlockTensor usable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/utils.jl#LL173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!-Tuple{TensorNetwork, Symbol}" href="#Base.delete!-Tuple{TensorNetwork, Symbol}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete!(tn::TensorNetwork, tensor_id::Symbol)</code></pre><p>Function to remove a tensor from a tensor network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL431-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!-Tuple{TensorNetworkCircuit, Symbol}" href="#Base.delete!-Tuple{TensorNetworkCircuit, Symbol}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete!(tnc::TensorNetworkCircuit, tensor_id::Symbol)</code></pre><p>Function to remove a tensor from a tensor network circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network_circuit.jl#LL115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{QXTns.BlockTensor{T, N, M}, Vararg{Any, N} where N}} where {T, N, M}" href="#Base.getindex-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{QXTns.BlockTensor{T, N, M}, Vararg{Any, N} where N}} where {T, N, M}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getindex(t::BlockTensor{T, N, M}, i...) where {T, N, M}</code></pre><p>Overload the getindex function. Returns zero if the indiex on ranks identified as hyperindex groups differ and the relevant tensor index otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/utils.jl#LL181-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge-Tuple{TensorNetwork, TensorNetwork}" href="#Base.merge-Tuple{TensorNetwork, TensorNetwork}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge(a::TensorNetwork, b::TensorNetwork)</code></pre><p>Join two networks together</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Tuple{TensorNetwork, QXTensor}" href="#Base.push!-Tuple{TensorNetwork, QXTensor}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push!(tn::TensorNetwork,
      tensor::QXTensor;
      tid::Union{Nothing, Symbol}=nothing)</code></pre><p>Function to add a tensor to the tensor network.</p><p><strong>Keywords</strong></p><ul><li><code>tid::Union{Nothing, Symbol}=nothing</code>: the id for the new tensor in <code>tn</code>. An id is</li></ul><p>generated if one is not set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL184-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Union{Tuple{N}, Tuple{T}, Tuple{TensorNetwork, Vector{var&quot;#s27&quot;} where var&quot;#s27&quot;&lt;:Index, Array{T, N}}} where {T, N}" href="#Base.push!-Union{Tuple{N}, Tuple{T}, Tuple{TensorNetwork, Vector{var&quot;#s27&quot;} where var&quot;#s27&quot;&lt;:Index, Array{T, N}}} where {T, N}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push!(tn::TensorNetwork,
      indices::Vector{Index},
      data::Array{T, N}
      tid::Union{Nothing, Symbol}=nothing) where {T, N}</code></pre><p>Function to add a tensor to the tensor network.</p><p><strong>Keywords</strong></p><ul><li><code>tid::Union{Nothing, Symbol}=nothing</code>: the id for the new tensor in <code>tn</code>. An id is</li></ul><p>generated if one is not set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL153-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Union{Tuple{T}, Tuple{TensorNetworkCircuit, Vector{Int64}, Matrix{T}}} where T" href="#Base.push!-Union{Tuple{T}, Tuple{TensorNetworkCircuit, Vector{Int64}, Matrix{T}}} where T"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push!(tnc::TensorNetworkCircuit,
      qubits::Vector{Int64},
      data::Array{T, 2}) where T</code></pre><p>Function to add a gate to the tensor network circuit given the qubits it acts on and an array of the matrix elements</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network_circuit.jl#LL73-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, QXTensor}" href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, QXTensor}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Custom show for QXTensors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor.jl#LL19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{QXTensor}" href="#Base.size-Tuple{QXTensor}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Custom size function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor.jl#LL27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.inds-Tuple{QXTensor}" href="#NDTensors.inds-Tuple{QXTensor}"><code>NDTensors.inds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implement inds for QXTensor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor.jl#LL29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.store-Tuple{QXTensor}" href="#NDTensors.store-Tuple{QXTensor}"><code>NDTensors.store</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implement store for QXTensor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor.jl#LL31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.add_input!" href="#QXTns.add_input!"><code>QXTns.add_input!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_input!(tnc::TensorNetworkCircuit; input::Union{String, Nothing}=nothing)</code></pre><p>Function to add input tensors to the circuit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network_circuit.jl#LL154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.add_output!" href="#QXTns.add_output!"><code>QXTns.add_output!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_output!(tnc::TensorNetworkCircuit; output::Union{String, Nothing}=nothing)</code></pre><p>Function to add output tensors to the circuit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network_circuit.jl#LL164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.contract_pair!" href="#QXTns.contract_pair!"><code>QXTns.contract_pair!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">contract_pair!(tn::TensorNetwork, a_sym::Symbol, b_sym::Symbol, c_sym::Symbol=:_; mock::Bool=false)</code></pre><p>Contract the tensors in &#39;tn&#39; with ids &#39;a<em>sym&#39; and &#39;b</em>sym&#39;. If the mock flag is true then the new tensor will be a mock tensor with the right dimensions but without the actual data.</p><p>The resulting tensor is stored in <code>tn</code> under the symbol <code>c_sym</code> if one is provided, otherwise a new id is created for it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL266-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.contract_pair-Tuple{TensorNetwork, Symbol, Symbol}" href="#QXTns.contract_pair-Tuple{TensorNetwork, Symbol, Symbol}"><code>QXTns.contract_pair</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_pair(tn::TensorNetwork, a_sym::Symbol, b_sym::Symbol; mock::Bool=false)</code></pre><p>Contract the tensors in &#39;tn&#39; with ids &#39;a<em>sym&#39; and &#39;b</em>sym&#39;. If the mock flag is true then the new tensor will be a mock tensor with the right dimensions but without the actual data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL238-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.contract_tensors-Tuple{QXTensor, QXTensor}" href="#QXTns.contract_tensors-Tuple{QXTensor, QXTensor}"><code>QXTns.contract_tensors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_tensors(a::QXTensor, b::QXTensor; mock::Bool=false)</code></pre><p>Function to contract two QXTensors and return another QXTensor. If the mock flag is false or either of the input tensors use MockTensor then the storage for the final tensor will be of type MockTensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL518-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.contract_tn!-Tuple{TensorNetwork, Vector{Tuple{Symbol, Symbol, Symbol}}}" href="#QXTns.contract_tn!-Tuple{TensorNetwork, Vector{Tuple{Symbol, Symbol, Symbol}}}"><code>QXTns.contract_tn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_tn!(tn::TensorNetwork, plan)</code></pre><p>Contract the indices of &#39;tn&#39; according to &#39;plan&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL350-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.contraction_indices-Tuple{QXTensor, QXTensor}" href="#QXTns.contraction_indices-Tuple{QXTensor, QXTensor}"><code>QXTns.contraction_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contraction_indices((a::QXTensor,b::QXTensor)</code></pre><p>Function to work out the contraction indices that would be used to contract the given tensors. Exptected indices in Einstein notation using positive integers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL507-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.contraction_indices-Tuple{TensorNetwork, Symbol, Symbol}" href="#QXTns.contraction_indices-Tuple{TensorNetwork, Symbol, Symbol}"><code>QXTns.contraction_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contraction_indices(tn::TensorNetwork, a_sym::Symbol, b_sym::Symbol)</code></pre><p>Function to work out the contraction indices that would be used to contract the given tensors. Expected indices in Einstein notation using positive integers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL301-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.create_test_tnc-Tuple{}" href="#QXTns.create_test_tnc-Tuple{}"><code>QXTns.create_test_tnc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_test_tnc(;input::Union{String, Nothing}=nothing,
                output::Union{String, Nothing}=nothing,
                no_input::Bool=false,
                no_output::Bool=false,
                kwargs...)</code></pre><p>Create a tensor network circuit for a small example circuit, 3 qubit ghz preparation circuit in this case</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network_circuit.jl#LL185-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.decompose_gate" href="#QXTns.decompose_gate"><code>QXTns.decompose_gate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function decompose_gate!(gate_data::Array{&lt;:Number, 4},
                         threshold::AbstractFloat=1e-15)</code></pre><p>Function to decompose a tensor into two smaller tensors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/utils.jl#LL5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.decompose_tensor!-Tuple{TensorNetwork, Symbol, Vector{var&quot;#s27&quot;} where var&quot;#s27&quot;&lt;:Index}" href="#QXTns.decompose_tensor!-Tuple{TensorNetwork, Symbol, Vector{var&quot;#s27&quot;} where var&quot;#s27&quot;&lt;:Index}"><code>QXTns.decompose_tensor!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decompose_tensor!(tn::TensorNetwork,
                  tensor_id::Symbol,
                  left_indices::Array{&lt;:Index, 1};
                  contract_S_with::Symbol=:V,
                  kwargs...)</code></pre><p>Function to decompose a tensor in a tensor network using svd.</p><p><strong>Keywords</strong></p><ul><li><code>contract_S_with::Symbol=:V</code>: the maxtrix which should absorb the matrix of singular values</li><li><code>maxdim::Int</code>: the maximum number of singular values to keep.</li><li><code>mindim::Int</code>: the minimum number of singular values to keep.</li><li><code>cutoff::Float64</code>: set the desired truncation error of the SVD.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL366-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.disable_hyperindices!-Tuple{QXTensor}" href="#QXTns.disable_hyperindices!-Tuple{QXTensor}"><code>QXTns.disable_hyperindices!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">disable_hyperindices!(t::QXTensor)</code></pre><p>Function to disable use of hyper indices with this tensor by removing the hyper indices and reshaping storage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor.jl#LL140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.expand_tensor-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Vector{Vector{Int64}}}} where {Elt, N}" href="#QXTns.expand_tensor-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Vector{Vector{Int64}}}} where {Elt, N}"><code>QXTns.expand_tensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_tensor(A::AbstractArray{Elt, N}, hyper_index_groups::Array{Int64, 1})</code></pre><p>Function to expand the rank of the given tensor assuming the given hyper edge groups. Like a generalisation of Diagonal. For example if passed a vector and given hyperindex groups [1,2], it will return a matrix where non diagonal elements are zero. Returns a a BlockTensor object which does not store &quot;off-diagonal&quot; elements.</p><pre><code class="language-none">julia&gt; expand_tensor([1, 2], [[1, 2]])
BlockTensor with dims (2, 2) and index map (1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/utils.jl#LL202-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.find_connected_indices-Tuple{TensorNetwork, Index}" href="#QXTns.find_connected_indices-Tuple{TensorNetwork, Index}"><code>QXTns.find_connected_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_connected_indices(tn::TensorNetwork, bond::Index)</code></pre><p>Given a tensor network and an index in the network, find all indices that are related via hyper edge relations. Involves recurisively checking bonds connected to neighbouring tensors of any newly related edges found. Returns an array of all edges in the group including the initial edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL479-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.find_hyper_edges-Union{Tuple{AbstractArray{Elt, N}}, Tuple{N}, Tuple{Elt}} where {Elt, N}" href="#QXTns.find_hyper_edges-Union{Tuple{AbstractArray{Elt, N}}, Tuple{N}, Tuple{Elt}} where {Elt, N}"><code>QXTns.find_hyper_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function find_hyper_edges(A::AbstractArray{Elt, N}) where {Elt, N}</code></pre><p>Function to identify hyper edges of tensors. Returns an array of tuples of indices of the original tensor which can be identified</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/utils.jl#LL37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.get_hyperedges-Tuple{TensorNetwork}" href="#QXTns.get_hyperedges-Tuple{TensorNetwork}"><code>QXTns.get_hyperedges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_hyperedges(tn::TensorNetwork)::Array{Array{Symbol, 1}, 1}</code></pre><p>Return an array of hyperedges in the given tensornetwork <code>tn</code>.</p><p>Hyperedges are represented as arrays of tensor symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL459-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.hyperindices-Tuple{QXTensor}" href="#QXTns.hyperindices-Tuple{QXTensor}"><code>QXTns.hyperindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hyperindices(t::QXTensor)</code></pre><p>Function to get the hyper indices as an array of Indices. If the all_indices flag is true, then all indices are returned, if false then just the groups of 2 or more are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor.jl#LL122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.hyperindices-Tuple{TensorNetwork, Symbol}" href="#QXTns.hyperindices-Tuple{TensorNetwork, Symbol}"><code>QXTns.hyperindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hyperindices(tn::TensorNetwork, i::Symbol; global_hyperindices=true)</code></pre><p>Find groups of hyper indices for the given tensor. When global_hyperindices is set to true, then indices which are identified as hyperindices because of groups of hyperindices in conneted tensors in the network are also included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL67-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.indices2ranks-Tuple{QXTensor, Vector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:(Vector{var&quot;#s28&quot;} where var&quot;#s28&quot;&lt;:Index)}" href="#QXTns.indices2ranks-Tuple{QXTensor, Vector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:(Vector{var&quot;#s28&quot;} where var&quot;#s28&quot;&lt;:Index)}"><code>QXTns.indices2ranks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">indices2ranks(tensor::QXTensor, hi::Vector{&lt;:Vector{&lt;:Index}})</code></pre><p>Function convert groups of indices to groups of index positions (ranks).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor.jl#LL107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.isdiagonal-Union{Tuple{AbstractMatrix{Elt}}, Tuple{Elt}} where Elt" href="#QXTns.isdiagonal-Union{Tuple{AbstractMatrix{Elt}}, Tuple{Elt}} where Elt"><code>QXTns.isdiagonal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isdiagonal(A::AbstractArray{Elt, 2}) where Elt</code></pre><p>Function to check if the given matrix is diagonal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/utils.jl#LL90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.isdiagonal-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Pair{Int64, Int64}}} where {Elt, N}" href="#QXTns.isdiagonal-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Pair{Int64, Int64}}} where {Elt, N}"><code>QXTns.isdiagonal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isdiagonal(A::AbstractArray{Elt, N}, Pair{Int64, Int64}) where {Elt, N}</code></pre><p>Function to check if the given matrix is diagonal along given axes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/utils.jl#LL74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.neighbours-Tuple{TensorNetwork, Symbol}" href="#QXTns.neighbours-Tuple{TensorNetwork, Symbol}"><code>QXTns.neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">neighbours(tn::TensorNetwork, tensor::Symbol)</code></pre><p>Function get the symbols of the neighbouring tensors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.push_input!-Union{Tuple{Elt}, Tuple{TensorNetworkCircuit, Vector{Elt}, Int64}} where Elt" href="#QXTns.push_input!-Union{Tuple{Elt}, Tuple{TensorNetworkCircuit, Vector{Elt}, Int64}} where Elt"><code>QXTns.push_input!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push_input!(tnc::TensorNetworkCircuit, tensor::Array{Elt, 1}, pos::Int64) where Elt</code></pre><p>Function to add a single input tensor to the tensor network circuit at the given position</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network_circuit.jl#LL126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.push_output!-Union{Tuple{Elt}, Tuple{TensorNetworkCircuit, Vector{Elt}, Int64}} where Elt" href="#QXTns.push_output!-Union{Tuple{Elt}, Tuple{TensorNetworkCircuit, Vector{Elt}, Int64}} where Elt"><code>QXTns.push_output!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push_output!(tnc::TensorNetworkCircuit, tensor::Array{Elt, 1}, pos::Int64) where Elt</code></pre><p>Function to add a single output tensor to the tensor network circuit at the given position</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network_circuit.jl#LL140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.reduce_tensor-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Vector{Vector{Int64}}}} where {Elt, N}" href="#QXTns.reduce_tensor-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Vector{Vector{Int64}}}} where {Elt, N}"><code>QXTns.reduce_tensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reduce_tensor(A::AbstractArray{Elt, N}, hyper_index_groups::Array{Int64, 1})</code></pre><p>Function to reduce the rank of the given tensor assuming the given hyper edge groups. For example a diagonal matrix will have a single hyper edge group with both indices [1, 2]. This function will reduce this to a vector containing only the diagonal elements. can be seen as a generalisation of the diag function.</p><pre><code class="language-julia-repl">julia&gt; reduce_tensor([[1, 0] [0, 2]], [[1, 2]])
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/utils.jl#LL118-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.replace_tensor_symbol!-Tuple{TensorNetwork, Symbol, Symbol}" href="#QXTns.replace_tensor_symbol!-Tuple{TensorNetwork, Symbol, Symbol}"><code>QXTns.replace_tensor_symbol!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replace_tensor_symbol!(tn::TensorNetwork, orig_sym::Symbol, new_sym::Symbol)</code></pre><p>Replace the given symbol with the given new symbol</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL445-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.simple_contraction!-Tuple{TensorNetwork}" href="#QXTns.simple_contraction!-Tuple{TensorNetwork}"><code>QXTns.simple_contraction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simple_contraction!(tn::TensorNetwork)</code></pre><p>Function to perfrom a simple contraction, contracting all tensors in order. Only useful for very small networks for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL223-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.simple_contraction-Tuple{TensorNetwork}" href="#QXTns.simple_contraction-Tuple{TensorNetwork}"><code>QXTns.simple_contraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simple_contraction(tn::TensorNetwork)</code></pre><p>Function to perfrom a simple contraction, contracting all tensors in order. Only useful for very small networks for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL211-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.tensor_data-Tuple{QXTensor}" href="#QXTns.tensor_data-Tuple{QXTensor}"><code>QXTns.tensor_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tensor_data(tensor::QXTensor; consider_hyperindices::Bool=true)</code></pre><p>Get the data associated with the given tensor. If the consider<em>hyperindices flag is true then the rank is reduced to merge related indices. For example for a 5 rank tensor where the 2nd and 4th indices form a group of hyper indices, with this option set to true would return a rank 4 tensor where the 2nd index has been merged with the 4th. With `consider</em>hyperindices` set to false a rank 5 tensor is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor.jl#LL86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTns.tensor_data-Tuple{TensorNetwork, Symbol}" href="#QXTns.tensor_data-Tuple{TensorNetwork, Symbol}"><code>QXTns.tensor_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tensor_data(tn::TensorNetwork, i::Symbol; consider_hyperindices=true, global_hyperindices=true)</code></pre><p>Retrieve the tensor data for the given tensor. If the consider<em>hyperindices flag is true then then the data is reshaped to take into account the local hyperindices of the tensor. If the global</em>hyperindices index is also true then groups of hyperindices related via hyperindices for other tensors in the network are also considered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTns.jl/blob/c8ce3cedb21b695ab062e081c54bef060ca85509/src/tensor_network.jl#LL90-L97">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="data_structures/">Data Structures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 22 January 2022 22:34">Saturday 22 January 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
